<!--
darc, the Durham Adaptive optics Real-time Controller.
Copyright (C) 2010 Alastair Basden.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<displayset date="09/09/18 22:56:09/18/09">
<plot pos="(0, 0)" size="(441, 337)" show="0" tbVal="(1,1,1)"><mangle>debug=1
cam=0
sameframe=1
if streamTime.has_key("rtcCalPxlBuf"):
 pxltime=streamTime["rtcCalPxlBuf"][0]
elif streamTime.has_key("rtcPxlBuf"):
 pxltime=streamTime["rtcPxlBuf"][0]
else:
 pxltime=0
 print "streamTime for pixels not found"
if sameframe==1 and streamTime.has_key("rtcCentBuf") and (streamTime["rtcCentBuf"][0]!=streamTime["rtcSubLocBuf"][0] or streamTime["rtcCentBuf"][0]!=pxltime):
 freeze=0
 title="[Frozen] Camera %d"%cam
if freeze==0:#all frame numbers equal, so plot...
 title="Camera %d"%cam
 if stream.has_key("rtcCalPxlBuf"):
  data=stream["rtcCalPxlBuf"]
 elif stream.has_key("rtcPxlBuf"):
  data=stream["rtcPxlBuf"]
 else:
  print "No pxl stream found"
  data=numpy.zeros((128*128),numpy.float32)
 ncam=data.size/(128*128)
 if cam>=ncam:
  print "Cannot display camera %d from an %d cam system"%(cam+1,ncam)
  cam=0
  quit=1
 npxl=npxlx*npxly
 offset=npxl[:cam/2].sum()
 data=data[offset:offset+npxlx[cam/2]*npxly[cam/2]]
 data.shape=npxly[cam/2],npxlx[cam/2]
 if data.shape[1]==256:
  data=data[:,cam%2::2]
 import overlayMaker
 if not store.has_key("pattern"):
  store["pattern"]=overlayMaker.makePattern("cross",7)
 pattern=store["pattern"]
 if store.has_key("overlay"):
  overlay=store["overlay"]
 else:
  overlay=None
 #nsub=nsubx*nsuby
 offset=nsub[:cam/2].sum()
 if len(subapLocation.shape)==1:
  subapLocation.shape=subapLocation.shape[0]/6,6
 subflag=subapFlag#[offset:offset+nsub[cam/2]]#(subapLocation[:,2]!=0).astype(numpy.int32)
 subapLocation=subapLocation[offset:offset+nsub[cam/2]]
 if subapLocation.shape[0]!=49:
  subapLocation=subapLocation[cam%2::2].copy()
  subapLocation[:,3:5]-=cam%2
 if stream.has_key("rtcSubLocBuf"):
  sub=stream["rtcSubLocBuf"]
 if len(sub.shape)==1:
  sub.shape=sub.shape[0]/6,6
 sub=sub[offset:offset+nsub[cam/2]]
 if sub.shape[0]!=49:
  sub=sub[cam%2::2].copy()
  sub[:,3:5]-=cam%2
 
 if stream.has_key("rtcCentBuf"):
  cen=stream["rtcCentBuf"]
 subskip=subflag[:offset].sum()
 nsubaps=subflag[offset:offset+nsub[cam/2]].sum()
 #if nsubaps.shape[0]==98:
 # nsubaps=nsubaps[cam%2::2]
 #nsubaps=nsubaps.sum()
 cen=cen[subskip*2:subskip*2+nsubaps*2]
 if cen.size!=72:#more than 1 camera, so select the correct part.
  cen.shape=cen.size/2,2
  cen=cen[cam%2::2]
  cen=cen.ravel()
 subflag=subapFlag[offset:offset+nsub[cam/2]]#(subapLocation[:,2]!=0).astype(numpy.int32)
 if subflag.size!=49:
  subflag=subflag[cam%2::2]

 if tbVal[0] and tbVal[1]:
  overlay=overlayMaker.createSubapCentOverlay(cen,sub,subapLocation,subflag,pattern=pattern,out=overlay,npxlx=128,npxly=128)
 elif tbVal[0]:
  overlay=overlayMaker.createCentroidOverlay(cen,subapLocation,subflag,pattern=pattern,out=overlay,npxlx=128,npxly=128)
 elif tbVal[1]:
  overlay=overlayMaker.createSubapOverlay(sub,subflag,out=overlay,npxlx=128,npxly=128)
 else:
  overlay=None
 store["overlay"]=overlay
 if tbVal[2]:
  arrows=overlayMaker.createCentroidArrows(cen,subapLocation,subflag,scale=2,npxlx=npxlx,npxly=npxly,cam=cam)
tbNames=["Cents","Subaps","Arrows"]
</mangle>
<sub>[('rtcCalPxlBuf', 1, 100), ('rtcCentBuf', 1, 100), ('rtcSubLocBuf', 1, 100)]</sub>
</plot>
</displayset>
